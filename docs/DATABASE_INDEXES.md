# Database Indexes Documentation

## Обзор

Система использует составные индексы для оптимизации производительности запросов. Все индексы создаются через миграции.

## Индексы по таблицам

### matches

**Одиночные индексы:**

- `idx_user1` - на `userId1` (для поиска матчей пользователя)
- `idx_user2` - на `userId2` (для поиска матчей пользователя)
- `idx_event` - на `eventId` (для фильтрации по событиям)

**Составные индексы:**

- `idx_matches_user1_user2` - на `(userId1, userId2)`
  - **Использование:** Проверка существования матча между двумя пользователями
  - **Запрос:** `WHERE userId1 = ? AND userId2 = ?`
  - **Производительность:** O(log n) вместо O(n)

- `idx_matches_user1_created` - на `(userId1, createdAt)`
  - **Использование:** Получение матчей пользователя, отсортированных по дате
  - **Запрос:** `WHERE userId1 = ? ORDER BY createdAt DESC`
  - **Производительность:** Позволяет использовать индекс для сортировки

- `idx_matches_user2_created` - на `(userId2, createdAt)`
  - **Использование:** Получение матчей, где пользователь является второй стороной
  - **Запрос:** `WHERE userId2 = ? ORDER BY createdAt DESC`
  - **Производительность:** Позволяет использовать индекс для сортировки

### likes

**Одиночные индексы:**

- `idx_from_user` - на `fromUserId` (лайки от пользователя)
- `idx_to_user` - на `toUserId` (лайки к пользователю)
- `idx_event` - на `eventId` (фильтрация по событиям)
- `idx_from_to` - на `(fromUserId, toUserId)` (проверка взаимных лайков)

**Составные индексы:**

- `idx_likes_from_to_event` - на `(fromUserId, toUserId, eventId)`
  - **Использование:** Проверка взаимных лайков в контексте события
  - **Запрос:** `WHERE fromUserId = ? AND toUserId = ? AND eventId = ?`
  - **Производительность:** Оптимизирует проверку взаимных лайков на событиях

- `idx_likes_to_created` - на `(toUserId, createdAt)`
  - **Использование:** Получение полученных лайков, отсортированных по дате
  - **Запрос:** `WHERE toUserId = ? ORDER BY createdAt DESC`
  - **Производительность:** Позволяет использовать индекс для сортировки

### messages

**Одиночные индексы:**

- `idx_match` - на `matchId` (сообщения в матче)
- `idx_sender` - на `senderId` (сообщения от пользователя)

**Составные индексы:**

- `idx_messages_match_created` - на `(matchId, createdAt)`
  - **Использование:** Получение сообщений в матче, отсортированных по дате
  - **Запрос:** `WHERE matchId = ? ORDER BY createdAt ASC`
  - **Производительность:** Позволяет использовать индекс для сортировки

## Оптимизация запросов

### Пример 1: Проверка существования матча

**До оптимизации:**

```sql
SELECT COUNT(*) FROM matches
WHERE (userId1 = ? AND userId2 = ?) OR (userId1 = ? AND userId2 = ?);
-- Использует полное сканирование таблицы: O(n)
```

**После оптимизации:**

```sql
SELECT COUNT(*) FROM matches
WHERE (userId1 = ? AND userId2 = ?) OR (userId1 = ? AND userId2 = ?);
-- Использует составной индекс idx_matches_user1_user2: O(log n)
```

### Пример 2: Получение матчей пользователя

**До оптимизации:**

```sql
SELECT * FROM matches
WHERE userId1 = ? OR userId2 = ?
ORDER BY createdAt DESC;
-- OR условие не может эффективно использовать индексы
```

**После оптимизации:**

```sql
SELECT * FROM (
  SELECT * FROM matches WHERE userId1 = ?
  UNION ALL
  SELECT * FROM matches WHERE userId2 = ?
)
ORDER BY createdAt DESC;
-- Использует idx_matches_user1_created и idx_matches_user2_created
```

## Мониторинг производительности

### Проверка использования индексов

В YDB можно проверить использование индексов через:

```sql
-- План выполнения запроса покажет, какие индексы используются
EXPLAIN SELECT * FROM matches WHERE userId1 = ? AND userId2 = ?;
```

### Метрики для мониторинга

- Время выполнения запросов `matchExists()` - должно быть < 10ms
- Время выполнения запросов `getMatchesByUserId()` - должно быть < 50ms
- Количество сканированных строк - должно быть минимальным

## Миграция

Индексы создаются автоматически при запуске миграций:

```bash
npm run migrate
```

Миграция `003_add_composite_indexes` создаст все составные индексы.

## Best Practices

1. **Не создавайте слишком много индексов**
   - Каждый индекс замедляет INSERT/UPDATE операции
   - Создавайте только для часто используемых запросов

2. **Используйте составные индексы для WHERE + ORDER BY**
   - Если запрос фильтрует и сортирует, создайте составной индекс

3. **Порядок колонок в индексе важен**
   - Первая колонка должна быть в WHERE
   - Последняя колонка может быть в ORDER BY

4. **Мониторьте производительность**
   - Регулярно проверяйте медленные запросы
   - Анализируйте планы выполнения

## Troubleshooting

### Индекс не используется

1. Проверьте, что запрос использует колонки в правильном порядке
2. Убедитесь, что индекс создан: `npm run migrate:status`
3. Проверьте план выполнения: `EXPLAIN <query>`

### Медленные запросы

1. Проверьте, используются ли индексы
2. Рассмотрите добавление новых индексов для частых запросов
3. Оптимизируйте запросы (избегайте OR, используйте UNION)

### Ошибки при создании индекса

1. Проверьте, что таблица существует
2. Убедитесь, что нет дублирующихся индексов
3. Проверьте логи миграций
